Реализация: Для взаимодействия использованы функции POSIX: shm_open, mmap, ftruncate, shm_unlink. В разделяемой памяти реализована структура данных, содержащая:
	•data — случайное число, генерируемое клиентом;
	•is_updated — флаг, указывающий на наличие новых данных;
	•should_exit — флаг завершения работы;
	•client_pid — PID процесса клиента.

Клиент при запуске записывает свой PID в сегмент памяти. Сервер ожидает появления PID клиента, после чего начинает чтение данных. 
Оба процесса регистрируют обработчик сигнала SIGINT (Ctrl+C), который устанавливает флаг should_exit = 1. 
Сервер периодически проверяет жизнеспособность клиента с помощью kill(client_pid, 0). При получении ошибки ESRCH (процесс не существует) сервер завершает работу. 
Функция shm_unlink вызывается через atexit, что гарантирует удаление сегмента памяти при любом завершении процесса — по сигналу или нормально.

Тестирование:
	•Сервер запущен в одном терминале, клиент — в другом.
	•При нажатии Ctrl+C в клиенте — сервер завершается и удаляет сегмент.
	•При нажатии Ctrl+C в сервере — клиент завершается и удаляет сегмент.
	•Повторные запуски не приводят к конфликтам — старый сегмент удаляется при старте сервера.
	•Все операции проходят корректно, без утечек памяти или висячих сегментов.

Вывод: Предложенный механизм обеспечивает безопасное завершение работы обоих процессов. 
       Использование PID для проверки жизнеспособности клиента и флага should_exit позволяет гарантировать корректное завершение при любом сценарии выхода. 
       Сегмент разделяемой памяти всегда удаляется.

