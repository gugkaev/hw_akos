Вариант34

1. Что делал?

Реализовал многопоточную модель библиотеки на языке C с использованием POSIX Threads (pthreads).  
В системе есть N книг и M читателей. Каждый читатель — отдельный поток, который:
- выбирает от 1 до 3 случайных книг,
- пытается их взять (если какая-то занята — ждёт),
- читает их 1–3 секунды,
- возвращает всё обратно.

Программа запускается так: `./library <число_книг> <число_читателей>`.

2. Как решал задачу?

Основные идеи:
- Каждая книга имеет флаг «доступна/занята» и свою условную переменную (`pthread_cond_t`).
- Все операции над состоянием книг защищены одним мьютексом (`library_mutex`), чтобы избежать гонок.
- Читатель не берёт книги в случайном порядке — **он сортирует их по ID перед взятием**. Это ключевой момент: именно так я избежал взаимоблокировок (deadlock), когда два читателя «перекрывают» друг друга по двум разным книгам.
- Ожидание реализовано через `pthread_cond_wait()` в цикле `while (!available)`, что корректно обрабатывает спонтанные пробуждения.
- Как только книга возвращается, все ждущие получают сигнал через `pthread_cond_broadcast()`.

Логирование событий ведётся с уникальным счётчиком, чтобы было удобно отслеживать ход выполнения.

3. Почему решение корректно?

- **Deadlock невозможен**: упорядоченный захват ресурсов (по ID) — стандартный и надёжный способ предотвратить циклические зависимости.
- **Голодание практически исключено**: все ждущие читатели получают сигнал одновременно, и в POSIX-реализациях (особенно на Linux) планировщик обычно даёт шанс каждому.
- **Нет гонок**: вся общая память защищена мьютексом.
- **Нет утечек**: все выделенные ресурсы (память, мьютексы, условные переменные) аккуратно освобождаются даже при ошибках.

4. Альтернативные подходы

Сначала я подумал: а что, если брать книги в том порядке, в котором читатель их выбрал? Но быстро понял — это путь к deadlock’у.  
Рассмотрел вариант с таймаутами и повторными попытками, но он сложнее, не гарантирует завершения и не соответствует условию «ждать, пока не освободится».  
Поэтому выбрал **упорядоченный захват** — простое, надёжное и широко применяемое решение в промышленном коде.

5. Тестирование

Программа протестирована на разных конфигурациях:

- `./library 3 5` — все читатели получают книги, ждут при необходимости, завершаются корректно.
- `./library 2 10` — высокая конкуренция, но всё работает: никто не зависает, все получают доступ.
- `./library 10 3` — низкая конкуренция, книги почти всегда свободны, работа завершается быстро.

Во всех случаях лог показывает логичную последовательность событий: ожидание → получение → возврат.

6. Вывод

Программа полностью соответствует условию задачи №34. Она:
- использует только POSIX Threads,
- корректно синхронизирует доступ,
- не имеет deadlock’ов и гонок,
- аккуратно логирует всё происходящее,
- устойчива к ошибкам и масштабируема в рамках разумных пределов.
